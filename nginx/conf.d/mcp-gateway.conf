# NGINX MCP Gateway Server Block
# Include this in your nginx.conf: include /path/to/nginx-mcp-gateway/nginx/conf.d/*.conf;

# Import njs handler - UPDATE THIS PATH
js_import mcp from /Users/monyet/develop/home/nginx-mcp-gateway/nginx/njs/mcp-handler.js;

# Upstream backends
upstream default_backend {
    server localhost:8080;
    keepalive 32;
}

# MCP Gateway Server
server {
    listen 3000;
    server_name mcp-gateway;

    # Logging
    access_log /opt/homebrew/var/log/nginx/mcp-access.log;
    error_log /opt/homebrew/var/log/nginx/mcp-error.log;

    # Static files (homepage, etc)
    root /Users/monyet/develop/home/nginx-mcp-gateway/public;

    # Homepage
    location = / {
        try_files /index.html =404;
    }

    # Health check
    location /health {
        access_log off;
        return 200 '{"status":"healthy","service":"nginx-mcp-gateway"}';
        add_header Content-Type application/json;
    }

    # Initialize handler (load tools.json)
    location /init {
        js_content mcp.init;
    }

    # Main MCP endpoint - HTTP POST for JSON-RPC
    location /mcp {
        # CORS headers for browser clients
        add_header Access-Control-Allow-Origin * always;
        add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS' always;
        add_header Access-Control-Allow-Headers 'Content-Type, Authorization' always;

        if ($request_method = 'OPTIONS') {
            return 204;
        }

        # Process MCP requests via njs
        js_content mcp.handleMCPRequest;
    }

    # SSE endpoint for streaming responses (future)
    location /mcp/sse {
        js_content mcp.handleSSE;

        # SSE-specific settings
        proxy_buffering off;
        proxy_cache off;
        proxy_read_timeout 24h;
    }

    # Internal backend proxy locations
    # These are called by the njs handler via subrequest

    # Legacy endpoint-based routing
    location /backend/ {
        internal;
        proxy_pass http://default_backend/;
        proxy_set_header Content-Type application/json;
        proxy_set_header Host $host;
    }

    # Function-based routing via /execute endpoint
    # Each backend has its own /execute endpoint that receives:
    # { "function": "function_name", "arguments": {...} }

    # Memory backend (port 3003)
    # Note: Using ^~ to prevent regex locations from taking precedence
    location ^~ /execute/memory {
        internal;

        # Pass through the request body from the parent request
        proxy_pass http://localhost:3003/execute;
        proxy_set_header Content-Type application/json;
        proxy_set_header Host $host;
    }

    # Mesh backend (port 3002) - future
    location ^~ /execute/mesh {
        internal;
        proxy_pass http://localhost:3002/execute;
        proxy_set_header Content-Type application/json;
        proxy_set_header Host $host;
    }

    # Recall backend (port 3006) - future
    location ^~ /execute/recall {
        internal;
        proxy_pass http://localhost:3006/execute;
        proxy_set_header Content-Type application/json;
        proxy_set_header Host $host;
    }

    # Default execute endpoint (fallback)
    # Note: Using rewrite since regex locations can't have URI in proxy_pass
    location ~ ^/execute/(.+)$ {
        internal;
        rewrite ^/execute/.+$ /execute break;
        proxy_pass http://default_backend;
        proxy_set_header Content-Type application/json;
        proxy_set_header Host $host;
    }
}
